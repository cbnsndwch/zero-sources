## API Report File for "@cbnsndwch/zero-contracts"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { CustomMutatorDefs } from '@rocicorp/zero';
import { CustomMutatorImpl } from '@rocicorp/zero';
import { LoggerService } from '@nestjs/common';
import { Request as Request_2 } from 'express';
import { SchemaValueToTSType } from 'node_modules/@rocicorp/zero/out/zero-schema/src/table-schema.js';
import { TableBuilderWithColumns } from '@rocicorp/zero';
import { TableSchema } from '@rocicorp/zero';
import { Type } from '@nestjs/common';
import { ValueType } from '@rocicorp/zero';

// @public
export function addFields(fields: Record<string, any>): SetStage;

// @public
export type AlternativeType<T> = T extends ReadonlyArray<infer U> ? T | RegExpOrString<U> : RegExpOrString<T>;

// @public (undocumented)
export type AtLeastOne<T> = [T, ...T[]];

// @public (undocumented)
export type Condition<T> = AlternativeType<T> | FilterOperators<AlternativeType<T>>;

// Warning: (ae-forgotten-export) The symbol "CorsOptionsDelegate" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const corsDelegate: CorsOptionsDelegate<Request_2>;

// @public (undocumented)
export type Dict<T = any> = {
    [key: string]: T;
};

// @public
export type DocumentPath = `$${string}`;

// @public (undocumented)
export type ExtractMutatorKeys<TContext extends ServerMutatorContext, Mutators extends ServerMutatorDefs<TContext>> = {
    readonly [K in keyof Mutators]: Mutators[K] extends ServerMutatorImpl<TContext> ? K & string : keyof Mutators[K] extends string ? `${K & string}|${keyof Mutators[K] & string}` : never;
}[keyof Mutators];

// @public
export type Filter<T> = RootFilterOperators<T> & {
    [K in keyof T]?: Condition<T[K]>;
};

// @public (undocumented)
export type FilterOperators<T> = {
    $eq?: T;
    $ne?: T;
    $gt?: T;
    $gte?: T;
    $lt?: T;
    $lte?: T;
    $in?: ReadonlyArray<T>;
    $nin?: ReadonlyArray<T>;
    $not?: T extends string ? FilterOperators<T> | RegExp : FilterOperators<T>;
    $exists?: boolean;
    $regex?: T extends string ? RegExp | string : never;
    $options?: T extends string ? string : never;
    $all?: ReadonlyArray<any>;
    $size?: T extends ReadonlyArray<any> ? number : never;
};

// @public
export function groupTablesBySource<const TTables extends readonly TableBuilderWithColumns<TableSchema>[]>(schema: TypedSchema<TTables>, mapping: TableMappings<TTables>): Dict<TableNames<TTables>[]>;

// @public
export function invariant<TError extends Error = Error>(condition: boolean | (() => boolean), message: string | (() => string), errorClass?: Type<TError>, logger?: LoggerService): asserts condition;

// @public
export function isPipelineMapping<T>(mapping: TableMapping<T>): mapping is PipelineTableMapping<T>;

// @public
export function isSimpleMapping<T>(mapping: TableMapping<T>): mapping is SimpleTableMapping<T>;

// @public
export interface IWatermarkService {
    getOrCreateWatermark(shardId: string, resumeToken: string): Promise<string>;
    getResumeToken(shardId: string, watermark: LexiVersion): Promise<string | undefined>;
}

// @public
export type LexiVersion = string;

// @public
export function match<T>(filter: Filter<T>): MatchStage<T>;

// @public
export interface MatchStage<T = Dict> {
    // (undocumented)
    $match: Filter<T>;
}

// @public (undocumented)
export function max(...versions: AtLeastOne<LexiVersion>): LexiVersion;

// @public (undocumented)
export function min(...versions: AtLeastOne<LexiVersion>): LexiVersion;

// @public
export type MutatorKeysForSchema<Schema extends Schema, Mutators extends CustomMutatorDefs> = {
    readonly [K in keyof Mutators]: Mutators[K] extends CustomMutatorImpl<Schema> ? K & string : keyof Mutators[K] extends string ? `${K & string}|${keyof Mutators[K] & string}` : never;
}[keyof Mutators];

// @public (undocumented)
export function oneAfter(version: LexiVersion): string;

// @public (undocumented)
export function parseBigInt(val: string, radix: number): bigint;

// @public
export class PassthroughWatermarkService implements IWatermarkService {
    // (undocumented)
    getOrCreateWatermark(_shardId: string, resumeToken: string): Promise<string>;
    // (undocumented)
    getResumeToken(_shardId: string, watermark: LexiVersion): Promise<string>;
}

// @public
export function pipelineBuilder<T>(source: string): PipelineMappingBuilder<T>;

// @public
export class PipelineMappingBuilder<T> {
    constructor(source: string);
    addFields(fields: Record<string, any>): this;
    build(): PipelineTableMapping<T>;
    match(filter: Filter<any>): this;
    project(projection: Record<string, 1 | 0 | DocumentPath | ProjectionOperator>): this;
    projection(proj: PipelineTableMapping<T>['projection']): this;
    unwind(path: string): this;
    // (undocumented)
    unwind(options: UnwindOptions): this;
}

// @public
export type PipelineStage<T = Dict> = MatchStage<T> | UnwindStage | SetStage | ProjectStage<T>;

// @public
export interface PipelineTableMapping<TTable = Dict> {
    // (undocumented)
    filter?: never;
    pipeline: PipelineStage<TTable>[];
    // (undocumented)
    projection?: never;
    source: string;
}

// @public
export function project<T = Dict>(projection: Projection<T>): ProjectStage<T>;

// @public (undocumented)
export type Projection<TTable = Dict> = Record<keyof TTable, 1 | 0 | DocumentPath | ProjectionOperator>;

// @public
export type ProjectionOperator = {
    [operator: `$${string}`]: DocumentPath | ProjectionOperator | Array<DocumentPath | ProjectionOperator | string | number | boolean> | string | number | boolean;
};

// @public
export interface ProjectStage<T = Dict> {
    $project: Projection<T>;
}

// @public (undocumented)
export type RegExpOrString<T> = T extends string ? RegExp | T : T;

// @public (undocumented)
export type RootFilterOperators<T> = Dict & {
    $and?: Filter<T>[];
    $or?: Filter<T>[];
};

// @public
export type RowOf<T extends TableBuilderWithColumns<TableSchema>> = {
    [K in keyof T['schema']['columns']]: SchemaValueToTSType<T['schema']['columns'][K]>;
};

// @public (undocumented)
export type ServerMutatorContext = unknown;

// @public
export type ServerMutatorDefs<TContext extends ServerMutatorContext> = {
    [namespaceOrKey: string]: ServerMutatorImpl<TContext> | {
        [key: string]: ServerMutatorImpl<TContext>;
    };
};

// @public
export type ServerMutatorImpl<TContext extends ServerMutatorContext, TArgs = any> = {
    (context: TContext, args: TArgs): Promise<void>;
};

// @public
export interface SetStage {
    // (undocumented)
    $addFields: Dict;
}

// @public
export interface SimpleTableMapping<TTable = Dict> {
    filter?: Filter<TTable>;
    // (undocumented)
    pipeline?: never;
    projection?: Projection<TTable>;
    source: string;
}

// @public
export type TableMapping<TTable = Dict> = SimpleTableMapping<TTable> | PipelineTableMapping<TTable>;

// @public (undocumented)
export type TableMappings<TTables extends readonly TableBuilderWithColumns<TableSchema>[]> = Record<TableNames<TTables>, TableMapping<unknown>>;

// @public (undocumented)
export type TableNames<TTables extends readonly TableBuilderWithColumns<TableSchema>[]> = TTables[number]['schema']['name'];

// @public
export const TOKEN_WATERMARK_SERVICE: unique symbol;

// @public
export function toPipelineMapping<T>(mapping: SimpleTableMapping<T>): PipelineTableMapping<T>;

// @public
export function truncateBytes(msg: string, maxBytes?: number): string;

// @public (undocumented)
export type TypedSchema<TTables extends readonly TableBuilderWithColumns<TableSchema>[]> = {
    tables: {
        readonly [K in TTables[number]['schema']['name']]: Extract<TTables[number]['schema'], {
            name: K;
        }>;
    };
};

// @public
export function unwind(path: string): UnwindStage;

// @public
export function unwind(options: UnwindOptions): UnwindStage;

// @public
export interface UnwindOptions<T = Dict> {
    includeArrayIndex?: string;
    path: keyof T;
    preserveNullAndEmptyArrays?: boolean;
}

// @public
export interface UnwindStage<T = Dict> {
    // (undocumented)
    $unwind: keyof T | UnwindOptions;
}

// @public (undocumented)
export function versionFromLexi(lexiVersion: LexiVersion): bigint;

// @public (undocumented)
export function versionToLexi(v: number | bigint): LexiVersion;

// @public
export const WS_1000_NORMAL_CLOSURE = 1000;

// @public
export const WS_1001_GOING_AWAY = 1001;

// @public
export const WS_1002_PROTOCOL_ERROR = 1002;

// @public
export const WS_1003_UNSUPPORTED_DATA = 1003;

// @public
export const WS_1005_NO_STATUS_RECEIVED = 1005;

// @public
export const WS_1006_ABNORMAL_CLOSURE = 1006;

// @public
export const WS_1007_INVALID_FRAME_PAYLOAD_DATA = 1007;

// @public
export const WS_1008_POLICY_VIOLATION = 1008;

// @public
export const WS_1009_MESSAGE_TOO_BIG = 1009;

// @public
export const WS_1010_MANDATORY_EXTENSIONS = 1010;

// @public
export const WS_1011_INTERNAL_ERROR = 1011;

// @public
export const WS_1012_SERVICE_RESTART = 1012;

// @public
export const WS_1013_TRY_AGAIN_LATER = 1013;

// @public
export const WS_1014_BAD_GATEWAY = 1014;

// @public
export const WS_1015_TLS_HANDSHAKE = 1015;

// @public
export const WS_3000_UNAUTHORIZED = 3000;

// @public
export const WS_3003_FORBIDDEN = 3003;

// @public
export const WS_3008_TIMEOUT = 3008;

// @public
export const WS_4900_UNDERLYING_STREAM_CLOSED = 4900;

// @public
export const WS_CLOSE_REASON_MAX_BYTES = 123;

// @public
export const WsCloseCode: {
    WS_1000_NORMAL_CLOSURE: number;
    WS_1001_GOING_AWAY: number;
    WS_1002_PROTOCOL_ERROR: number;
    WS_1003_UNSUPPORTED_DATA: number;
    WS_1005_NO_STATUS_RECEIVED: number;
    WS_1006_ABNORMAL_CLOSURE: number;
    WS_1007_INVALID_FRAME_PAYLOAD_DATA: number;
    WS_1008_POLICY_VIOLATION: number;
    WS_1009_MESSAGE_TOO_BIG: number;
    WS_1010_MANDATORY_EXTENSIONS: number;
    WS_1011_INTERNAL_ERROR: number;
    WS_1012_SERVICE_RESTART: number;
    WS_1013_TRY_AGAIN_LATER: number;
    WS_1014_BAD_GATEWAY: number;
    WS_1015_TLS_HANDSHAKE: number;
    WS_3000_UNAUTHORIZED: number;
    WS_3003_FORBIDDEN: number;
    WS_3008_TIMEOUT: number;
    WS_4900_UNDERLYING_STREAM_CLOSED: number;
};

// @public
export const ZERO_VALUE_TYPE_TO_PG_TYPE: Record<ValueType, string>;

// @public
export type ZeroConfig = {
    auth: {
        token: string;
    };
    kv: {
        provider: 'zqlite';
        zqlite: {
            file: string;
        };
    };
    tableMapping?: {
        [clientName: string]: TableMapping;
    };
};

// (No @packageDocumentation comment for this package)

```
