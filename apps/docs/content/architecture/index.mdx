---
title: Architecture
description: System design and technical architecture of Zero Sources
icon: box
---

# Architecture

Learn about the technical architecture, design decisions, and system structure of Zero Sources.

## Overview

Zero Sources implements a **three-container architecture** for real-time data synchronization:

```
┌─────────────────┐     ┌─────────────┐     ┌────────────┐
│  MongoDB        │────▶│  Change     │────▶│  Zero      │
│  Database       │     │  Source     │     │  Cache     │
└─────────────────┘     └─────────────┘     └────────────┘
                                                    │
                                                    ▼
                                            ┌────────────┐
                                            │  Client    │
                                            │  Apps      │
                                            └────────────┘
```

## Core Components

<Cards>
  <Card title="Change Source Protocol" href="/architecture/change-source-protocol" icon="flow">
    Protocol for streaming database changes
  </Card>
  <Card title="Watermark System" href="/architecture/watermark-system" icon="bookmark">
    Client synchronization progress tracking
  </Card>
  <Card title="Monorepo Structure" href="/architecture/monorepo-structure" icon="folder">
    Organization of code and packages
  </Card>
</Cards>

## Design Principles

### 1. Schema-First Design

Define data structures once, use everywhere:

```typescript
const schema = createTableSchema({
  tableName: 'message',
  columns: { /* ... */ },
  primaryKey: ['id'],
});
```

### 2. Application-Agnostic Change Sources

Change sources load schema dynamically, making them reusable across applications.

### 3. Incremental Synchronization

Only changed data is transmitted, minimizing bandwidth and improving performance.

### 4. Offline-First

Clients work offline, queuing changes for later synchronization.

### 5. Type Safety

Full TypeScript support throughout the stack.

## System Architecture

### Data Flow

1. **Change Detection**: MongoDB emits change stream events
2. **Transformation**: Change source converts to Zero protocol
3. **Streaming**: WebSocket pushes changes to Zero cache
4. **Caching**: Zero cache updates local state
5. **Propagation**: Clients receive updates in real-time

### Scaling Strategy

- **Horizontal Scaling**: Run multiple change source instances
- **Stateless Design**: No shared state between instances
- **Load Balancing**: Distribute WebSocket connections
- **Database Sharding**: Partition data across MongoDB shards

## Technology Choices

### Why NestJS?

- Mature, production-ready framework
- Excellent TypeScript support
- Built-in WebSocket support
- Modular architecture
- Dependency injection

### Why MongoDB?

- Change streams for real-time updates
- Flexible schema for rapid iteration
- Replica sets for high availability
- Rich query capabilities

### Why Rocicorp Zero?

- Optimized for offline-first applications
- Automatic conflict resolution
- Efficient synchronization protocol
- Strong typing support

## Performance Considerations

### Change Stream Optimization

- Use filtered change streams
- Batch change events
- Implement backpressure handling

### WebSocket Optimization

- Enable compression
- Batch messages
- Implement connection pooling

### Database Optimization

- Index frequently queried fields
- Use projections to limit data
- Implement sharding for scale

## Security Architecture

### Authentication

- JWT-based authentication
- Client identification
- Token validation

### Authorization

- Row-level security
- Client-specific filtering
- Permission validation

### Data Protection

- Encrypted connections (TLS)
- Secure token storage
- Input validation

## Next Steps

- [Change Source Protocol](./change-source-protocol)
- [Watermark System](./watermark-system)
- [Monorepo Structure](./monorepo-structure)
